package cwl;
/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
@SuppressWarnings("all")
/** 
When listed under `inputBinding` in the input schema, the term
"value" refers to the the corresponding value in the input object.  For
binding objects listed in `CommandLineTool.arguments`, the term "value"
refers to the effective value after evaluating `valueFrom`.

The binding behavior when building the command line depends on the data
type of the value.  If there is a mismatch between the type described by
the input schema and the effective value, such as resulting from an
expression evaluation, an implementation must use the data type of the
effective value.

  - **string**: Add `prefix` and the string to the command line.

  - **number**: Add `prefix` and decimal representation to command line.

  - **boolean**: If true, add `prefix` to the command line.  If false, add
      nothing.

  - **File**: Add `prefix` and the value of
    [`File.path`](#File) to the command line.

  - **array**: If `itemSeparator` is specified, add `prefix` and the join
      the array into a single string with `itemSeparator` separating the
      items.  Otherwise first add `prefix`, then recursively process
      individual elements.

  - **object**: Add `prefix` only, and recursively add object fields for
      which `inputBinding` is specified.

  - **null**: Add nothing.
 */
@org.apache.avro.specific.AvroGenerated
public class CommandLineBinding extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"CommandLineBinding\",\"doc\":\"\\nWhen listed under `inputBinding` in the input schema, the term\\n\\\"value\\\" refers to the the corresponding value in the input object.  For\\nbinding objects listed in `CommandLineTool.arguments`, the term \\\"value\\\"\\nrefers to the effective value after evaluating `valueFrom`.\\n\\nThe binding behavior when building the command line depends on the data\\ntype of the value.  If there is a mismatch between the type described by\\nthe input schema and the effective value, such as resulting from an\\nexpression evaluation, an implementation must use the data type of the\\neffective value.\\n\\n  - **string**: Add `prefix` and the string to the command line.\\n\\n  - **number**: Add `prefix` and decimal representation to command line.\\n\\n  - **boolean**: If true, add `prefix` to the command line.  If false, add\\n      nothing.\\n\\n  - **File**: Add `prefix` and the value of\\n    [`File.path`](#File) to the command line.\\n\\n  - **array**: If `itemSeparator` is specified, add `prefix` and the join\\n      the array into a single string with `itemSeparator` separating the\\n      items.  Otherwise first add `prefix`, then recursively process\\n      individual elements.\\n\\n  - **object**: Add `prefix` only, and recursively add object fields for\\n      which `inputBinding` is specified.\\n\\n  - **null**: Add nothing.\\n\",\"fields\":[{\"name\":\"loadContents\",\"type\":[\"null\",\"boolean\"],\"doc\":\"Only applies when `type` is `File`.  Read up to the first 64 KiB of text from the file and place it in the\\n\\\"contents\\\" field of the file object for manipulation by expressions.\\n\",\"inherited_from\":\"https://w3id.org/cwl/cwl#Binding\"},{\"name\":\"secondaryFiles\",\"type\":[\"null\",\"string\",{\"type\":\"enum\",\"name\":\"Expression\",\"doc\":\"Not a real type.  Indicates that a field must allow expressions.\\n\",\"symbols\":[\"ExpressionPlaceholder\"]},{\"type\":\"array\",\"items\":[\"string\",\"Expression\"]}],\"doc\":\"Only applies when `type` is `File`.  Describes files that must be\\nincluded alongside the primary file.\\n\\nIf the value is an expression, the context of the expression is the input\\nor output File parameter to which this binding applies.\\n\\nIf the value is a string, it specifies that the following pattern\\nshould be applied to the primary file:\\n\\n  1. If string begins with one or more caret `^` characters, for each\\n    caret, remove the last file extension from the path (the last\\n    period `.` and all following characters).  If there are no file\\n    extensions, the path is unchanged.\\n  2. Append the remainder of the string to the end of the file path.\\n\",\"jsonldPredicate\":\"cwl:secondaryFiles\",\"inherited_from\":\"https://w3id.org/cwl/cwl#Binding\"},{\"name\":\"position\",\"type\":[\"null\",\"int\"],\"doc\":\"The sorting key.  Default position is 0.\"},{\"name\":\"prefix\",\"type\":[\"null\",\"string\"],\"doc\":\"Command line prefix to add before the value.\"},{\"name\":\"separate\",\"type\":[\"null\",\"boolean\"],\"doc\":\"If true (default), then the prefix and value must be added as separate\\ncommand line arguments; if false, prefix and value must be concatenated\\ninto a single command line argument.\\n\"},{\"name\":\"itemSeparator\",\"type\":[\"null\",\"string\"],\"doc\":\"Join the array elements into a single string with the elements\\nseparated by by `itemSeparator`.\\n\"},{\"name\":\"valueFrom\",\"type\":[\"null\",\"string\",\"Expression\"],\"doc\":\"If `valueFrom` is a constant string value, use this as the value and\\napply the binding rules above.\\n\\nIf `valueFrom` is an expression, evaluate the expression to yield the\\nactual value to use to build the command line and apply the binding\\nrules above.  If the inputBinding is associated with an input\\nparameter, the \\\"context\\\" of the expression will be the value of the\\ninput parameter.\\n\\nWhen a binding is part of the `CommandLineTool.arguments` field,\\nthe `valueFrom` field is required.\\n\",\"jsonldPredicate\":\"cwl:valueFrom\"},{\"name\":\"shellQuote\",\"type\":[\"null\",\"boolean\"],\"doc\":\"If `ShellCommandRequirement` is in the requirements for the current command,\\nthis controls whether the value is quoted on the command line (default is true).\\nUse `shellQuote: false` to inject metacharacters for operations such as pipes.\\n\"}],\"extends\":\"https://w3id.org/cwl/cwl#Binding\"}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** Only applies when `type` is `File`.  Read up to the first 64 KiB of text from the file and place it in the
"contents" field of the file object for manipulation by expressions.
 */
  @Deprecated public java.lang.Boolean loadContents;
  /** Only applies when `type` is `File`.  Describes files that must be
included alongside the primary file.

If the value is an expression, the context of the expression is the input
or output File parameter to which this binding applies.

If the value is a string, it specifies that the following pattern
should be applied to the primary file:

  1. If string begins with one or more caret `^` characters, for each
    caret, remove the last file extension from the path (the last
    period `.` and all following characters).  If there are no file
    extensions, the path is unchanged.
  2. Append the remainder of the string to the end of the file path.
 */
  @Deprecated public java.lang.Object secondaryFiles;
  /** The sorting key.  Default position is 0. */
  @Deprecated public java.lang.Integer position;
  /** Command line prefix to add before the value. */
  @Deprecated public java.lang.CharSequence prefix;
  /** If true (default), then the prefix and value must be added as separate
command line arguments; if false, prefix and value must be concatenated
into a single command line argument.
 */
  @Deprecated public java.lang.Boolean separate;
  /** Join the array elements into a single string with the elements
separated by by `itemSeparator`.
 */
  @Deprecated public java.lang.CharSequence itemSeparator;
  /** If `valueFrom` is a constant string value, use this as the value and
apply the binding rules above.

If `valueFrom` is an expression, evaluate the expression to yield the
actual value to use to build the command line and apply the binding
rules above.  If the inputBinding is associated with an input
parameter, the "context" of the expression will be the value of the
input parameter.

When a binding is part of the `CommandLineTool.arguments` field,
the `valueFrom` field is required.
 */
  @Deprecated public java.lang.Object valueFrom;
  /** If `ShellCommandRequirement` is in the requirements for the current command,
this controls whether the value is quoted on the command line (default is true).
Use `shellQuote: false` to inject metacharacters for operations such as pipes.
 */
  @Deprecated public java.lang.Boolean shellQuote;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>. 
   */
  public CommandLineBinding() {}

  /**
   * All-args constructor.
   */
  public CommandLineBinding(java.lang.Boolean loadContents, java.lang.Object secondaryFiles, java.lang.Integer position, java.lang.CharSequence prefix, java.lang.Boolean separate, java.lang.CharSequence itemSeparator, java.lang.Object valueFrom, java.lang.Boolean shellQuote) {
    this.loadContents = loadContents;
    this.secondaryFiles = secondaryFiles;
    this.position = position;
    this.prefix = prefix;
    this.separate = separate;
    this.itemSeparator = itemSeparator;
    this.valueFrom = valueFrom;
    this.shellQuote = shellQuote;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return loadContents;
    case 1: return secondaryFiles;
    case 2: return position;
    case 3: return prefix;
    case 4: return separate;
    case 5: return itemSeparator;
    case 6: return valueFrom;
    case 7: return shellQuote;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: loadContents = (java.lang.Boolean)value$; break;
    case 1: secondaryFiles = (java.lang.Object)value$; break;
    case 2: position = (java.lang.Integer)value$; break;
    case 3: prefix = (java.lang.CharSequence)value$; break;
    case 4: separate = (java.lang.Boolean)value$; break;
    case 5: itemSeparator = (java.lang.CharSequence)value$; break;
    case 6: valueFrom = (java.lang.Object)value$; break;
    case 7: shellQuote = (java.lang.Boolean)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'loadContents' field.
   * Only applies when `type` is `File`.  Read up to the first 64 KiB of text from the file and place it in the
"contents" field of the file object for manipulation by expressions.
   */
  public java.lang.Boolean getLoadContents() {
    return loadContents;
  }

  /**
   * Sets the value of the 'loadContents' field.
   * Only applies when `type` is `File`.  Read up to the first 64 KiB of text from the file and place it in the
"contents" field of the file object for manipulation by expressions.
   * @param value the value to set.
   */
  public void setLoadContents(java.lang.Boolean value) {
    this.loadContents = value;
  }

  /**
   * Gets the value of the 'secondaryFiles' field.
   * Only applies when `type` is `File`.  Describes files that must be
included alongside the primary file.

If the value is an expression, the context of the expression is the input
or output File parameter to which this binding applies.

If the value is a string, it specifies that the following pattern
should be applied to the primary file:

  1. If string begins with one or more caret `^` characters, for each
    caret, remove the last file extension from the path (the last
    period `.` and all following characters).  If there are no file
    extensions, the path is unchanged.
  2. Append the remainder of the string to the end of the file path.
   */
  public java.lang.Object getSecondaryFiles() {
    return secondaryFiles;
  }

  /**
   * Sets the value of the 'secondaryFiles' field.
   * Only applies when `type` is `File`.  Describes files that must be
included alongside the primary file.

If the value is an expression, the context of the expression is the input
or output File parameter to which this binding applies.

If the value is a string, it specifies that the following pattern
should be applied to the primary file:

  1. If string begins with one or more caret `^` characters, for each
    caret, remove the last file extension from the path (the last
    period `.` and all following characters).  If there are no file
    extensions, the path is unchanged.
  2. Append the remainder of the string to the end of the file path.
   * @param value the value to set.
   */
  public void setSecondaryFiles(java.lang.Object value) {
    this.secondaryFiles = value;
  }

  /**
   * Gets the value of the 'position' field.
   * The sorting key.  Default position is 0.   */
  public java.lang.Integer getPosition() {
    return position;
  }

  /**
   * Sets the value of the 'position' field.
   * The sorting key.  Default position is 0.   * @param value the value to set.
   */
  public void setPosition(java.lang.Integer value) {
    this.position = value;
  }

  /**
   * Gets the value of the 'prefix' field.
   * Command line prefix to add before the value.   */
  public java.lang.CharSequence getPrefix() {
    return prefix;
  }

  /**
   * Sets the value of the 'prefix' field.
   * Command line prefix to add before the value.   * @param value the value to set.
   */
  public void setPrefix(java.lang.CharSequence value) {
    this.prefix = value;
  }

  /**
   * Gets the value of the 'separate' field.
   * If true (default), then the prefix and value must be added as separate
command line arguments; if false, prefix and value must be concatenated
into a single command line argument.
   */
  public java.lang.Boolean getSeparate() {
    return separate;
  }

  /**
   * Sets the value of the 'separate' field.
   * If true (default), then the prefix and value must be added as separate
command line arguments; if false, prefix and value must be concatenated
into a single command line argument.
   * @param value the value to set.
   */
  public void setSeparate(java.lang.Boolean value) {
    this.separate = value;
  }

  /**
   * Gets the value of the 'itemSeparator' field.
   * Join the array elements into a single string with the elements
separated by by `itemSeparator`.
   */
  public java.lang.CharSequence getItemSeparator() {
    return itemSeparator;
  }

  /**
   * Sets the value of the 'itemSeparator' field.
   * Join the array elements into a single string with the elements
separated by by `itemSeparator`.
   * @param value the value to set.
   */
  public void setItemSeparator(java.lang.CharSequence value) {
    this.itemSeparator = value;
  }

  /**
   * Gets the value of the 'valueFrom' field.
   * If `valueFrom` is a constant string value, use this as the value and
apply the binding rules above.

If `valueFrom` is an expression, evaluate the expression to yield the
actual value to use to build the command line and apply the binding
rules above.  If the inputBinding is associated with an input
parameter, the "context" of the expression will be the value of the
input parameter.

When a binding is part of the `CommandLineTool.arguments` field,
the `valueFrom` field is required.
   */
  public java.lang.Object getValueFrom() {
    return valueFrom;
  }

  /**
   * Sets the value of the 'valueFrom' field.
   * If `valueFrom` is a constant string value, use this as the value and
apply the binding rules above.

If `valueFrom` is an expression, evaluate the expression to yield the
actual value to use to build the command line and apply the binding
rules above.  If the inputBinding is associated with an input
parameter, the "context" of the expression will be the value of the
input parameter.

When a binding is part of the `CommandLineTool.arguments` field,
the `valueFrom` field is required.
   * @param value the value to set.
   */
  public void setValueFrom(java.lang.Object value) {
    this.valueFrom = value;
  }

  /**
   * Gets the value of the 'shellQuote' field.
   * If `ShellCommandRequirement` is in the requirements for the current command,
this controls whether the value is quoted on the command line (default is true).
Use `shellQuote: false` to inject metacharacters for operations such as pipes.
   */
  public java.lang.Boolean getShellQuote() {
    return shellQuote;
  }

  /**
   * Sets the value of the 'shellQuote' field.
   * If `ShellCommandRequirement` is in the requirements for the current command,
this controls whether the value is quoted on the command line (default is true).
Use `shellQuote: false` to inject metacharacters for operations such as pipes.
   * @param value the value to set.
   */
  public void setShellQuote(java.lang.Boolean value) {
    this.shellQuote = value;
  }

  /** Creates a new CommandLineBinding RecordBuilder */
  public static CommandLineBinding.Builder newBuilder() {
    return new CommandLineBinding.Builder();
  }
  
  /** Creates a new CommandLineBinding RecordBuilder by copying an existing Builder */
  public static CommandLineBinding.Builder newBuilder(CommandLineBinding.Builder other) {
    return new CommandLineBinding.Builder(other);
  }
  
  /** Creates a new CommandLineBinding RecordBuilder by copying an existing CommandLineBinding instance */
  public static CommandLineBinding.Builder newBuilder(CommandLineBinding other) {
    return new CommandLineBinding.Builder(other);
  }
  
  /**
   * RecordBuilder for CommandLineBinding instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<CommandLineBinding>
    implements org.apache.avro.data.RecordBuilder<CommandLineBinding> {

    private java.lang.Boolean loadContents;
    private java.lang.Object secondaryFiles;
    private java.lang.Integer position;
    private java.lang.CharSequence prefix;
    private java.lang.Boolean separate;
    private java.lang.CharSequence itemSeparator;
    private java.lang.Object valueFrom;
    private java.lang.Boolean shellQuote;

    /** Creates a new Builder */
    private Builder() {
      super(CommandLineBinding.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(CommandLineBinding.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.loadContents)) {
        this.loadContents = data().deepCopy(fields()[0].schema(), other.loadContents);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.secondaryFiles)) {
        this.secondaryFiles = data().deepCopy(fields()[1].schema(), other.secondaryFiles);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.position)) {
        this.position = data().deepCopy(fields()[2].schema(), other.position);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.prefix)) {
        this.prefix = data().deepCopy(fields()[3].schema(), other.prefix);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.separate)) {
        this.separate = data().deepCopy(fields()[4].schema(), other.separate);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.itemSeparator)) {
        this.itemSeparator = data().deepCopy(fields()[5].schema(), other.itemSeparator);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.valueFrom)) {
        this.valueFrom = data().deepCopy(fields()[6].schema(), other.valueFrom);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.shellQuote)) {
        this.shellQuote = data().deepCopy(fields()[7].schema(), other.shellQuote);
        fieldSetFlags()[7] = true;
      }
    }
    
    /** Creates a Builder by copying an existing CommandLineBinding instance */
    private Builder(CommandLineBinding other) {
            super(CommandLineBinding.SCHEMA$);
      if (isValidValue(fields()[0], other.loadContents)) {
        this.loadContents = data().deepCopy(fields()[0].schema(), other.loadContents);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.secondaryFiles)) {
        this.secondaryFiles = data().deepCopy(fields()[1].schema(), other.secondaryFiles);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.position)) {
        this.position = data().deepCopy(fields()[2].schema(), other.position);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.prefix)) {
        this.prefix = data().deepCopy(fields()[3].schema(), other.prefix);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.separate)) {
        this.separate = data().deepCopy(fields()[4].schema(), other.separate);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.itemSeparator)) {
        this.itemSeparator = data().deepCopy(fields()[5].schema(), other.itemSeparator);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.valueFrom)) {
        this.valueFrom = data().deepCopy(fields()[6].schema(), other.valueFrom);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.shellQuote)) {
        this.shellQuote = data().deepCopy(fields()[7].schema(), other.shellQuote);
        fieldSetFlags()[7] = true;
      }
    }

    /** Gets the value of the 'loadContents' field */
    public java.lang.Boolean getLoadContents() {
      return loadContents;
    }
    
    /** Sets the value of the 'loadContents' field */
    public CommandLineBinding.Builder setLoadContents(java.lang.Boolean value) {
      validate(fields()[0], value);
      this.loadContents = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'loadContents' field has been set */
    public boolean hasLoadContents() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'loadContents' field */
    public CommandLineBinding.Builder clearLoadContents() {
      loadContents = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'secondaryFiles' field */
    public java.lang.Object getSecondaryFiles() {
      return secondaryFiles;
    }
    
    /** Sets the value of the 'secondaryFiles' field */
    public CommandLineBinding.Builder setSecondaryFiles(java.lang.Object value) {
      validate(fields()[1], value);
      this.secondaryFiles = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'secondaryFiles' field has been set */
    public boolean hasSecondaryFiles() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'secondaryFiles' field */
    public CommandLineBinding.Builder clearSecondaryFiles() {
      secondaryFiles = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'position' field */
    public java.lang.Integer getPosition() {
      return position;
    }
    
    /** Sets the value of the 'position' field */
    public CommandLineBinding.Builder setPosition(java.lang.Integer value) {
      validate(fields()[2], value);
      this.position = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'position' field has been set */
    public boolean hasPosition() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'position' field */
    public CommandLineBinding.Builder clearPosition() {
      position = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'prefix' field */
    public java.lang.CharSequence getPrefix() {
      return prefix;
    }
    
    /** Sets the value of the 'prefix' field */
    public CommandLineBinding.Builder setPrefix(java.lang.CharSequence value) {
      validate(fields()[3], value);
      this.prefix = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'prefix' field has been set */
    public boolean hasPrefix() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'prefix' field */
    public CommandLineBinding.Builder clearPrefix() {
      prefix = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'separate' field */
    public java.lang.Boolean getSeparate() {
      return separate;
    }
    
    /** Sets the value of the 'separate' field */
    public CommandLineBinding.Builder setSeparate(java.lang.Boolean value) {
      validate(fields()[4], value);
      this.separate = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'separate' field has been set */
    public boolean hasSeparate() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'separate' field */
    public CommandLineBinding.Builder clearSeparate() {
      separate = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /** Gets the value of the 'itemSeparator' field */
    public java.lang.CharSequence getItemSeparator() {
      return itemSeparator;
    }
    
    /** Sets the value of the 'itemSeparator' field */
    public CommandLineBinding.Builder setItemSeparator(java.lang.CharSequence value) {
      validate(fields()[5], value);
      this.itemSeparator = value;
      fieldSetFlags()[5] = true;
      return this; 
    }
    
    /** Checks whether the 'itemSeparator' field has been set */
    public boolean hasItemSeparator() {
      return fieldSetFlags()[5];
    }
    
    /** Clears the value of the 'itemSeparator' field */
    public CommandLineBinding.Builder clearItemSeparator() {
      itemSeparator = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /** Gets the value of the 'valueFrom' field */
    public java.lang.Object getValueFrom() {
      return valueFrom;
    }
    
    /** Sets the value of the 'valueFrom' field */
    public CommandLineBinding.Builder setValueFrom(java.lang.Object value) {
      validate(fields()[6], value);
      this.valueFrom = value;
      fieldSetFlags()[6] = true;
      return this; 
    }
    
    /** Checks whether the 'valueFrom' field has been set */
    public boolean hasValueFrom() {
      return fieldSetFlags()[6];
    }
    
    /** Clears the value of the 'valueFrom' field */
    public CommandLineBinding.Builder clearValueFrom() {
      valueFrom = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /** Gets the value of the 'shellQuote' field */
    public java.lang.Boolean getShellQuote() {
      return shellQuote;
    }
    
    /** Sets the value of the 'shellQuote' field */
    public CommandLineBinding.Builder setShellQuote(java.lang.Boolean value) {
      validate(fields()[7], value);
      this.shellQuote = value;
      fieldSetFlags()[7] = true;
      return this; 
    }
    
    /** Checks whether the 'shellQuote' field has been set */
    public boolean hasShellQuote() {
      return fieldSetFlags()[7];
    }
    
    /** Clears the value of the 'shellQuote' field */
    public CommandLineBinding.Builder clearShellQuote() {
      shellQuote = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    @Override
    public CommandLineBinding build() {
      try {
        CommandLineBinding record = new CommandLineBinding();
        record.loadContents = fieldSetFlags()[0] ? this.loadContents : (java.lang.Boolean) defaultValue(fields()[0]);
        record.secondaryFiles = fieldSetFlags()[1] ? this.secondaryFiles : (java.lang.Object) defaultValue(fields()[1]);
        record.position = fieldSetFlags()[2] ? this.position : (java.lang.Integer) defaultValue(fields()[2]);
        record.prefix = fieldSetFlags()[3] ? this.prefix : (java.lang.CharSequence) defaultValue(fields()[3]);
        record.separate = fieldSetFlags()[4] ? this.separate : (java.lang.Boolean) defaultValue(fields()[4]);
        record.itemSeparator = fieldSetFlags()[5] ? this.itemSeparator : (java.lang.CharSequence) defaultValue(fields()[5]);
        record.valueFrom = fieldSetFlags()[6] ? this.valueFrom : (java.lang.Object) defaultValue(fields()[6]);
        record.shellQuote = fieldSetFlags()[7] ? this.shellQuote : (java.lang.Boolean) defaultValue(fields()[7]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
